"\"\"\"Voice control helpers that parse commands and wrap speech engines.\"\"\"\n+\n+from __future__ import annotations\n+\n+import re\n+from dataclasses import dataclass\n+from enum import Enum, auto\n+from typing import Dict, Optional, Tuple\n+\n+try:\n+    import speech_recognition as sr\n+except ImportError:  # pragma: no cover - voice is optional\n+    sr = None\n+\n+\n+class VoiceCommandType(Enum):\n+    SEARCH = auto()\n+    PLAY_ALL = auto()\n+    PLAY_SPECIFIC = auto()\n+    CONTROL = auto()\n+\n+\n+@dataclass(frozen=True)\n+class VoiceCommand:\n+    command_type: VoiceCommandType\n+    query: Optional[str] = None\n+    index: Optional[int] = None\n+    action: Optional[str] = None\n+\n+\n+class VoiceParser:\n+    _control_map: Dict[str, str] = {\n+        \"pause\": \"pause\",\n+        \"resume\": \"play\",\n+        \"playback\": \"play\",\n+        \"stop\": \"stop\",\n+        \"next\": \"next\",\n+        \"next song\": \"next\",\n+        \"previous\": \"previous\",\n+        \"previous song\": \"previous\",\n+    }\n+\n+    def parse(self, phrase: str) -> VoiceCommand:\n+        normalized = phrase.lower().strip()\n+        if not normalized:\n+            raise ValueError(\"empty voice phrase\")\n+\n+        if \"play all\" in normalized:\n+            return VoiceCommand(command_type=VoiceCommandType.PLAY_ALL)\n+\n+        search_prefixes = (\"search for \", \"find \", \"play some \")\n+        for prefix in search_prefixes:\n+            if normalized.startswith(prefix):\n+                query = normalized[len(prefix) :].strip()\n+                if not query:\n+                    raise ValueError(\"no query supplied\")\n+                return VoiceCommand(command_type=VoiceCommandType.SEARCH, query=query)\n+\n+        match = re.match(r\"play (?:track )?number (\\d+)\", normalized)\n+        if match:\n+            index = int(match.group(1)) - 1\n+            if index < 0:\n+                raise ValueError(\"invalid track number\")\n+            return VoiceCommand(command_type=VoiceCommandType.PLAY_SPECIFIC, index=index)\n+\n+        if normalized.startswith(\"play song \") or normalized.startswith(\"play \"):\n+            remainder = (\n+                normalized.replace(\"play song \", \"\", 1)\n+                if normalized.startswith(\"play song \")\n+                else normalized[5:]\n+            ).strip()\n+            if remainder:\n+                return VoiceCommand(command_type=VoiceCommandType.PLAY_SPECIFIC, query=remainder)\n+\n+        if normalized in self._control_map:\n+            return VoiceCommand(command_type=VoiceCommandType.CONTROL, action=self._control_map[normalized])\n+\n+        raise ValueError(f\"unrecognized voice command: {phrase}\")\n+\n+\n+class SpeechEngine:\n+    def recognize_once(\n+        self,\n+        *,\n+        language: str,\n+        timeout: float,\n+        phrase_time_limit: float,\n+    ) -> str:\n+        raise NotImplementedError\n+\n+\n+class OfflineSpeechEngine(SpeechEngine):\n+    def __init__(self, sample_rate: int = 16000) -> None:\n+        if sr is None:\n+            raise RuntimeError(\"speech_recognition dependency not installed\")\n+        self._recognizer = sr.Recognizer()\n+        self._sample_rate = sample_rate\n+\n+    def recognize_once(\n+        self,\n+        *,\n+        language: str,\n+        timeout: float,\n+        phrase_time_limit: float,\n+    ) -> str:\n+        with sr.Microphone(sample_rate=self._sample_rate) as source:\n+            self._recognizer.adjust_for_ambient_noise(source, duration=0.5)\n+            audio = self._recognizer.listen(\n+                source, timeout=timeout, phrase_time_limit=phrase_time_limit\n+            )\n+        try:\n+            return self._recognizer.recognize_sphinx(audio, language=language)\n+        except sr.UnknownValueError as exc:\n+            raise RuntimeError(\"could not understand speech\") from exc\n+        except sr.RequestError as exc:\n+            raise RuntimeError(\"speech engine error\") from exc\n+\n+\n+class VoiceController:\n+    def __init__(\n+        self,\n+        *,\n+        enabled: bool,\n+        engine: str,\n+        language: str,\n+    ) -> None:\n+        self.enabled = enabled\n+        self.language = language\n+        self.engine = self._build_engine(engine) if enabled else None\n+        self.parser = VoiceParser()\n+\n+    def _build_engine(self, name: str) -> SpeechEngine:\n+        if name == \"offline_default\":\n+            return OfflineSpeechEngine()\n+        raise ValueError(f\"unsupported voice engine: {name}\")\n+\n+    def _ensure_ready(self) -> None:\n+        if not self.enabled:\n+            raise RuntimeError(\"voice control is disabled\")\n+        if self.engine is None:\n+            raise RuntimeError(\"voice engine not available\")\n+\n+    def listen_once(\n+        self,\n+        *,\n+        timeout: float = 5.0,\n+        phrase_time_limit: float = 5.0,\n+    ) -> Tuple[VoiceCommand, str]:\n+        self._ensure_ready()\n+        phrase = self.engine.recognize_once(\n+            language=self.language,\n+            timeout=timeout,\n+            phrase_time_limit=phrase_time_limit,\n+        )\n+        command = self.parser.parse(phrase)\n+        return command, phrase\n*** End Patch
